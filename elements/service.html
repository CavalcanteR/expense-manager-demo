<!--
Exposes methods for fetching data either from a server or local storage.

Currently, we will use a server if the server attribute is set.
If not, we'll use dummy data from a json file.

This approach will also allow us centralize offline handling in the future instead
of having every component deal with it separately.
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-localstorage/iron-localstorage.html">
<link rel="import" href="../scripts/moment-js.html">

<dom-module id="expense-service">
  <template>
    <iron-localstorage id="tokenStorage" name="auth-token" value="{{token}}"></iron-localstorage>
    <iron-localstorage id="expenses" name="expense-cache" value="{{expenses}}"></iron-localstorage>
  </template>
  <script>
    (function() {
      'use strict';
      Polymer({
        is: 'expense-service',

        properties: {
          token: {
            type: String
          },
          loggedIn: {
            type: Boolean,
            computed: '_loggedIn(token)',
            notify: true,
            reflectToAttribute: true
          },
          server: String,
          service: {
            type: Object,
            notify: true
          },
          expenses: Array
        },

        ready: function() {
          var _this = this;
          this.service = {
            login: _this.login.bind(_this),
            logout: _this.logout.bind(_this),
            getOverviewData: _this.getOverviewData.bind(_this),
            getExpenses: _this.getExpenses.bind(_this),
            saveExpense: _this.saveExpense.bind(_this),
            deleteExpense: _this.deleteExpense.bind(_this),
            getReceiptURL: _this.getReceiptURL.bind(_this)
          };
        },

        login: function(username, password) {
          if (this.server) {
            return this._loginToServer(username, password);
          } else {
            return this._loginLocal(username, password);
          }
        },

        logout: function() {
          this.token = null;
          this.expenses = null;
        },

        getOverviewData: function() {
          if (this.server) {
            return this._getOverviewDataFromServer();
          } else {
            return this._getOverviewDataLocal();
          }
        },

        getExpenses: function(params) {
          if (this.server) {
            return this._getExpensesFromServer(params);
          } else {
            return this._getExpensesLocal(params);
          }
        },

        saveExpense: function(id, formData, rawData) {
          if (this.server) {
            return this._saveExpenseToServer(id, formData);
          } else {
            return this._saveExpenseLocal(id, rawData);
          }
        },

        deleteExpense: function(id) {
          if (this.server) {
            return this._deleteExpenseFromServer(id);
          } else {
            return this._deleteExpenseLocal(id);
          }
        },

        getReceiptURL: function(id) {
          if (this.server) {
            return this.server + '/expenses/' + id + '/receipt.jpg?token=' + this.token;
          } else {
            var expense = this._findExpense(id);
            if (expense && expense.receipt && expense.receipt.indexOf('data:') >= 0) {
              return expense.receipt;
            } else {
              return 'images/default-receipt.jpg';
            }
          }
        },

        _loginToServer: function(username, password) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
              if (xhr.readyState === XMLHttpRequest.DONE) {
                if (xhr.status === 200) {
                  var json = JSON.parse(xhr.responseText);
                  if (json.token) {
                    _this.token = json.token;
                    _this.fire('logged-in');
                    resolve(json);
                  } else {
                    reject(json.message);
                  }
                }
              }
            };
            xhr.open('POST', _this.server + '/authenticate', true);
            xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            xhr.send(_this._serializeParams({
              username: username,
              password: password
            }));
          });
        },

        _getOverviewDataFromServer: function() {
          return this._ajax(this.server + '/expenses/overview');
        },

        _getExpensesFromServer: function(params) {
          return this._ajax(this.server + '/expenses', params);
        },

        _saveExpenseToServer: function(id, data) {
          var url = this.server + '/expenses';
          if (id) {
            url += '/' + id;
          }
          return this._postData(url, data);
        },

        _deleteExpenseFromServer: function(id) {
          var url = this.server + '/expenses/' + id;
          return this._ajax(url, {}, 'DELETE');
        },

        _loginLocal: function() {
          var _this = this;
          return new Promise(function(resolve) {
            _this.token = 'demologin';
            _this.fire('logged-in');
            resolve();
          });
        },

        _getOverviewDataLocal: function() {
          var _this = this;

          function calculateOverviewData() {

            var total = _this.expenses.filter(function(expense) {
                return expense.status === 'new';
              })
              .map(function(expense) {
                return expense.total;
              })
              .reduce(function(a, b) {
                return a + b;
              }, 0);

            var history = [];
            var oneYearAgo = moment().subtract(1, 'years');
            _this.expenses.filter(function(expense) {
              return moment(expense.date).isAfter(oneYearAgo);
            }).forEach(function(expense) {
              findMonth(expense.date, history).total += expense.total;
            });

            return {
              totalOwed: total,
              history: history
            };
          }

          function findMonth(rawDate, history) {
            var date = moment(rawDate);
            var month;

            history.forEach(function(m) {
              if (m.month === date.month() && m.year === date.year()) {
                month = m;
              }
            });

            if (!month) {
              month = {
                month: date.month(),
                year: date.year(),
                total: 0
              };
              history.push(month);
            }
            return month;
          }

          return new Promise(function(resolve) {
            if (_this.expenses) {
              resolve(calculateOverviewData());
            } else {
              _this._ajax('demodata.json')
                .then(function(json) {
                  _this.expenses = json;
                  resolve(calculateOverviewData());
                });
            }
          });
        },

        _getExpensesLocal: function(params) {
          var _this = this;

          function filterAndSort(params) {
            // Filter
            var result = _this.expenses
              .filter(function(expense) {
                return !(params.merchant && expense.merchant
                  .toUpperCase().indexOf(params.merchant.toUpperCase()) < 0);
              })
              .filter(function(expense) {
                return !(params.min && expense.total < params.min);
              })
              .filter(function(expense) {
                return !(params.max && expense.total > params.max);
              })
              .filter(function(expense) {
                if (params.status && params.status.length > 0) {
                  return _this._contains(params.status, expense.status);
                } else {
                  return true;
                }
              })
              .filter(function(expense) {
                if (params.start) {
                  var startDate = moment(params.start);
                  if (startDate.isValid() && moment(expense.date).isAfter(startDate)) {
                    return true;
                  } else {
                    return false;
                  }
                } else {
                  return true;
                }
              })
              .filter(function(expense) {
                if (params.end) {
                  var endDate = moment(params.end);
                  if (endDate.isValid() && moment(expense.date).isBefore(endDate)) {
                    return true;
                  } else {
                    return false;
                  }
                } else {
                  return true;
                }
              });

            // Sort
            if (params.sort) {
              var sortProperty = params.sort;
              var sortDirection = params.direction || 'desc';
              result.sort(function(a, b) {
                var res;
                if (!isNaN(a[sortProperty])) {
                  res = parseInt(a[sortProperty], 10) - parseInt(b[sortProperty], 10);
                } else {
                  // Let's pretend everything that's not a number is a string.
                  res = a[sortProperty].localeCompare(b[sortProperty]);
                }

                if ('desc' === sortDirection) {
                  res *= -1;
                }
                return res;
              });
            }

            // Return correct sub-array and metadata
            return {
              metadata: {
                index: params.index,
                count: params.count,
                totalcount: result.length
              },
              result: result.slice(params.index, params.index + params.count)
            };
          }

          return new Promise(function(resolve) {
            if (_this.expenses) {
              resolve(filterAndSort(params));
            } else {
              _this._ajax('demodata.json')
                .then(function(json) {
                  _this.expenses = json;
                  resolve(filterAndSort(params));
                });
            }
          });
        },

        _saveExpenseLocal: function(id, data) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            if (data) {
              var expense = _this._findExpense(id);

              if (data.total) {
                data.total = parseFloat(data.total.replace(/[^\d.]/g, ''));
              }
              if (expense) {
                expense.merchant = data.merchant;
                expense.total = data.total;
                expense.date = data.date;
                expense.comment = data.comment;
                expense.receipt = data.receipt;
              } else {
                data.id = new Date().getTime();
                data.status = 'New';
                _this.push('expenses', data);
              }
              resolve();
            } else {
              reject();
            }
          });
        },

        _deleteExpenseLocal: function(id) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            for (var i = 0; i < _this.expenses.length; i++) {
              var expense = _this.expenses[i];

              if (expense.id === id && expense.status === 'new') {
                _this.splice('expenses', i, 1);
                resolve();
                return;
              }
            }
            reject();
          });
        },

        _findExpense: function(id) {
          var expense = null;
          this.expenses.forEach(function(e) {
            if (e.id === id) {
              expense = e;
            }
          });
          return expense;
        },

        _serializeParams: function(params) {
          var serialized = [];
          for (var p in params) {
            // don't serialize empty/null values
            if (params.hasOwnProperty(p) && params[p]) {
              serialized.push(encodeURIComponent(p) + '=' + encodeURIComponent(params[p]));
            }
          }
          return serialized.join('&');
        },

        _ajax: function(url, params, method) {
          var _this = this;
          method = method || 'GET';
          return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
              if (xhr.readyState === XMLHttpRequest.DONE) {
                if (xhr.status >= 200 && xhr.status < 300) {
                  var json = JSON.parse(xhr.responseText);
                  resolve(json);
                } else {
                  reject('Received status ' + xhr.status);
                }
              }
            };
            if (params) {
              url += '?' + _this._serializeParams(params);
            }
            xhr.open(method, url, true);
            xhr.setRequestHeader('x-access-token', _this.token);
            xhr.send();
          });
        },

        _postData: function(url, body) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
              if (xhr.readyState === XMLHttpRequest.DONE) {
                if (xhr.status >= 200 && xhr.status < 300) {
                  var json = JSON.parse(xhr.responseText);
                  if (json.success) {
                    resolve(json);
                  } else {
                    reject(json);
                  }
                }
              }
            };
            xhr.open('POST', url, true);
            xhr.setRequestHeader('x-access-token', _this.token);
            xhr.send(body);
          });
        },

        _loggedIn: function(token) {
          return token ? true : false;
        },

        _contains: function(a, obj) {
          for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
              return true;
            }
          }
          return false;
        }
      });
    })();
  </script>
</dom-module>
